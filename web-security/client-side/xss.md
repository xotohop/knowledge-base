[Cross-site scripting](https://portswigger.net/web-security/cross-site-scripting)

[Cheat sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

## XSS PoC
`alert(document.domain)` or `print()`

## Reflected XSS
Функция поиска, которая получает поисковый запрос от пользователя в параметре URL:
`https://insecure-website.com/search?term=gift`

`<p>You searched for: gift</p>`

Эксплуатация:

`https://insecure-website.com/search?term=<script>/*+Bad+stuff+here...+*/</script>`

`<p>You searched for: <script>/* Bad stuff here... */</script></p>`

### XSS между тегами HTML
Когда контекст XSS представляет собой текст между тегами HTML, необходимо ввести несколько новых тегов HTML, предназначенных для запуска выполнения JavaScript.

[Reflected XSS into HTML context with most tags and attributes blocked](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-html-context-with-most-tags-and-attributes-blocked)

`<iframe src="https://your-lab-id.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E" onload=this.style.width='100px'>`

[Reflected XSS into HTML context with all tags blocked except custom ones](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-html-context-with-all-standard-tags-blocked)

`<script> location = 'https://your-lab-id.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x'; </script>`

[Reflected XSS with some SVG markup allowed](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-some-svg-markup-allowed)

`"><svg><animatetransform onbegin=alert(1)>`

### XSS в атрибутах тегов HTML
Когда контекст XSS находится в значении атрибута HTML-тега, иногда можно прервать значение атрибута, закрыть тег и ввести новый. Например:

`"><script>alert(document.domain)</script>`

Чаще всего в такой ситуации угловые скобки блокируются или кодируются, поэтому ваш ввод не может выйти за пределы тега, в котором он появляется. При условии, что вы можете прервать значение атрибута, вы можете ввести новый атрибут, который создает контекст, доступный для сценария, например, обработчик события. Например:

`" autofocus onfocus=alert(document.domain) x="`

Приведенная выше полезная нагрузка создает событие `onfocus`, которое будет выполнять JavaScript, когда элемент получает фокус, а также добавляет атрибут `autofocus`, чтобы попытаться вызвать событие `onfocus` автоматически без какого-либо взаимодействия с пользователем. Наконец, он добавляет `x="`, чтобы изящно исправить следующую разметку. 

Вы можете встретить сайты, которые кодируют угловые скобки, но при этом позволяют вводить атрибуты. Иногда такие инъекции возможны даже в тегах, которые обычно не вызывают автоматических событий, например, в каноническом теге. Это поведение можно использовать с помощью ключей доступа и взаимодействия с пользователем в **Chrome**. Ключи доступа позволяют создавать комбинации клавиш, которые ссылаются на определенный элемент. Атрибут `accesskey` позволяет определить букву, при нажатии которой в сочетании с другими клавишами (они различаются для разных платформ) будут происходить события. В следующем уроке вы сможете поэкспериментировать с ключами доступа и использовать канонический тег. 

`https://0af7003f04f4cba8c06055c5004e0084.web-security-academy.net/?%27accesskey=%27x%27onclick=%27alert(1)`

Чтобы запустить эксплойт, нажмите одну из следующих комбинаций клавиш:

Windows: `ALT+SHIFT+X`

MacOS: `CTRL+ALT+X`

Linux: `ALT+X`

### XSS в JavaScript
Когда контекстом XSS является некоторый существующий JavaScript в ответе, могут возникнуть самые разные ситуации, причем для успешной эксплуатации необходимы различные техники.
#### Завершение существующего сценария
В простейшем случае можно просто закрыть тег script, заключающий существующий JavaScript, и ввести несколько новых HTML-тегов, которые вызовут выполнение JavaScript. Например, если контекст XSS выглядит следующим образом:

`<script>`
`...`
`var input = 'controllable data here';`
`...`
`</script>`

то можно использовать следующую полезную нагрузку, чтобы вырваться из существующего JavaScript и выполнить свой собственный:

`</script><img src=1 onerror=alert(document.domain)>`

Это работает потому, что браузер сначала выполняет разбор HTML для идентификации элементов страницы, включая блоки сценариев, и только затем выполняет разбор JavaScript для понимания и выполнения встроенных сценариев. Приведенная выше полезная нагрузка оставляет исходный сценарий разрушенным, с не завершенным строковым литералом. Но это не мешает последующему сценарию быть разобранным и выполненным обычным способом. 
#### Выход из строки JavaScript
В случаях, когда XSS-контекст находится внутри quoted строкового литерала, часто можно вырваться из строки и выполнить JavaScript напрямую. Очень важно исправить сценарий, следующий за XSS-контекстом, потому что любые синтаксические ошибки в нем не позволят выполнить весь сценарий.

Некоторые полезные способы выхода за пределы строкового литерала: 

`'-alert(document.domain)-'`

`';alert(document.domain)//`

Некоторые приложения пытаются предотвратить выход ввода за пределы строки JavaScript, экранируя любые символы одинарной кавычки обратной косой чертой. Обратная косая черта перед символом говорит синтаксическому анализатору JavaScript, что этот символ следует интерпретировать буквально, а не как специальный символ, например, терминатор строки. В этой ситуации приложения часто совершают ошибку, не экранируя сам символ обратной косой черты. Это означает, что злоумышленник может использовать свой собственный символ обратной косой черты, чтобы нейтрализовать обратную косую черту, добавленную приложением.

Например, предположим, что ввод:

`';alert(document.domain)//`

преобразуется в:

`\';alert(document.domain)//`

Теперь вы можете использовать альтернативную полезную нагрузку:

`\';alert(document.domain)//`

которая преобразуется в:

`\\\';alert(document.domain)//`

Здесь первый обратный слеш означает, что второй обратный слеш интерпретируется буквально, а не как специальный символ. Это означает, что кавычка теперь интерпретируется как терминатор строки, и атака проходит успешно. 

Некоторые сайты усложняют XSS, ограничивая допустимые символы. Это может быть сделано на уровне сайта или путем развертывания WAF, который не позволяет вашим запросам достичь сайта. В таких ситуациях необходимо экспериментировать с другими способами вызова функций, которые позволяют обойти эти меры безопасности. Один из способов сделать это - использовать оператор `throw` с обработчиком исключений. Это позволяет передавать аргументы в функцию без использования круглых скобок. Следующий код назначает функцию `alert()` глобальному обработчику исключений, а оператор `throw` передает `1` обработчику исключений (в данном случае `alert`). В итоге функция `alert()` вызывается с 1 в качестве аргумента.

`onerror=alert;throw 1`

#### XSS в литералах шаблонов JavaScript
Шаблонные литералы JavaScript - это строковые литералы, в которые можно вставлять выражения JavaScript. Встроенные выражения выполняются и обычно конкатенируются в окружающий текст. Шаблонные литералы заключаются в бэктики вместо обычных кавычек, а встроенные выражения идентифицируются с помощью синтаксиса `${...}`.

Например, следующий сценарий выводит приветственное сообщение, включающее отображаемое имя пользователя:

``document.getElementById('message').innerText = `Welcome, ${user.displayName}.`;``

Когда XSS-контекст находится в литерале шаблона JavaScript, нет необходимости завершать литерал. Вместо этого нужно просто использовать синтаксис` ${...}` для вставки выражения JavaScript, которое будет выполнено при обработке литерала. Например, если XSS-контекст выглядит следующим образом:

`<script>`
`...`
``var input = `контролируемые данные здесь`;``
`...`
`</script>`

тогда вы можете использовать следующую полезную нагрузку для выполнения JavaScript без завершения литерала шаблона:

`${alert(document.domain)}`

## Stored XSS
Веб-сайт позволяет пользователям оставлять комментарии к записям в блоге, которые отображаются другим пользователям. Пользователи отправляют комментарии с помощью HTTP-запроса, как показано ниже: 

`POST /post/comment HTTP/1.1`
`Host: vulnerable-website.com`
`Content-Length: 100` 

`postId=3&comment=This+post+was+extremely+helpful.&name=Carlos+Montoya&email=carlos%40normal-user.net`

После отправки этого комментария любой пользователь, который посетит эту запись в блоге, получит в ответе приложения следующее:

`<p>This post was extremely helpful.</p>`

`<script>/* Bad stuff here... */</script>`

Эксплуатация:

`comment=%3Cscript%3E%2F*%2BBad%2Bstuff%2Bhere...%2B*%2F%3C%2Fscript%3E`

`<p><script>/* Bad stuff here... */</script></p>`

### XSS в атрибутах тегов HTML
Иногда XSS-контекст заключается в атрибуте HTML-тега, который сам по себе может создавать контекст для сценариев. Здесь можно выполнить JavaScript без необходимости завершать значение атрибута. Например, если контекст XSS находится в атрибуте `href` тега якоря, вы можете использовать псевдопротокол `javascript` для выполнения сценария. Например:

`<a href="javascript:alert(document.domain)">`

### XSS в JavaScript
#### Использование HTML-кодирования
Когда контекстом XSS является некоторый существующий JavaScript внутри атрибута quoted тега, например, обработчик события, можно использовать HTML-кодирование для обхода некоторых фильтров ввода.

Когда браузер разбирает HTML-теги и атрибуты в ответе, он выполняет HTML-декодирование значений атрибутов тегов перед их дальнейшей обработкой. Если приложение на стороне сервера блокирует или санирует определенные символы, которые необходимы для успешного XSS-эксплойта, вы часто можете обойти проверку ввода путем HTML-кодирования этих символов.

Например, если контекст XSS выглядит следующим образом:

`<a href="#" onclick="... var input='controllable data here'; ...">`

и приложение блокирует или экранирует символы одиночных кавычек, вы можете использовать следующую полезную нагрузку, чтобы выйти из строки JavaScript и выполнить свой собственный сценарий:

`&apos;-alert(document.domain)-&apos;`

Последовательность `&apos;` - это HTML-сущность, представляющая апостроф или одинарную кавычку. Поскольку браузер HTML-декодирует значение атрибута `onclick` до интерпретации JavaScript, сущности декодируются как кавычки, которые становятся разделителями строк, поэтому атака проходит успешно.

Из лабы [Stored XSS into onclick event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-onclick-event-angle-brackets-double-quotes-html-encoded-single-quotes-backslash-escaped):

`postId=9&comment=3&name=2&email=1%401.com&website=https%3A%2F%2F0ac3007c0345c54dc0d33269001600f4.web-security-academy.net%2Fpost%3FpostId%3D9%3f%26apos;-alert(document.domain)-%26apos;`

## DOM-based XSS
